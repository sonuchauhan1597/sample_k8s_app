name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Setup Minikube
      run: |
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        chmod +x minikube-linux-amd64
        sudo mv minikube-linux-amd64 /usr/local/bin/minikube
        minikube start
        alias kubectl="minikube kubectl --"

    - name: Build Docker Images
      run: |
        eval $(minikube docker-env)
        docker build -t nginx-test:1.19 .
        docker build -t backend:latest ./backend
        docker build -t frontend:latest ./frontend
        
    - name: Install Trivy
      run: |
        sudo apt-get install -y wget
        wget https://github.com/aquasecurity/trivy/releases/download/v0.25.0/trivy_0.25.0_Linux-64bit.deb
        sudo dpkg -i trivy_0.25.0_Linux-64bit.deb

    - name: Scan Docker image with Trivy
      run: |
        trivy image frontend:latest
        trivy image backend:latest
        trivy image nginx-test:1.19

    - name: Load image in minikube
      run: |
        minikube image load backend:latest
        minikube image load frontend:latest
        minikube image load nginx-test:1.19

    - name: Install kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/v1.24.0/bin/linux/amd64/kubectl"
        chmod +x ./kubectl
        sudo mv ./kubectl /usr/local/bin/kubectl
        kubectl version --client


    - name: Create Namespace
      run: |
        kubectl create namespace my-namespace || echo "Namespace already exists"
        minikube start

    - name: Use image from local
      run: |
        eval $(minikube -p minikube docker-env)

    - name: Apply Kubernetes Resources
      run: |
        kubectl apply -f ./kubernetes/backend-deployment.yaml
        kubectl apply -f ./kubernetes/frontend-deployment.yaml
        kubectl apply -f ./kubernetes/nginx-deployment.yaml
        kubectl apply -f ./kubernetes/nginx-service.yaml
        
    - name: Wait for Pods to be Ready
      run: |
        kubectl wait --for=condition=ready pod -l app=backend -n my-namespace --timeout=60s
        kubectl wait --for=condition=ready pod -l app=frontend -n my-namespace --timeout=60s
        kubectl wait --for=condition=ready pod -l app=nginx -n my-namespace --timeout=60s
        
    - name: See pods and deployments
      run: |
        kubectl get pods -n my-namespace
        kubectl get deploy -n my-namespace
        
    - name: Get localhost.run URL
      run: |
        # Fetch the public URL from localhost.run and set it as an output
        FRONTEND_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        echo "Frontend accessible at: $FRONTEND_URL"
        BACKEND_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[1].public_url')
        echo "Backend accessible at: $BACKEND_URL"
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_ENV
        echo "BACKEND_URL=$BACKEND_URL" >> $GITHUB_ENV

    - name: Output Public URL
      run: |
        echo "Access Frontend at: ${{ env.FRONTEND_URL }}"
        echo "Access Backend at: ${{ env.BACKEND_URL }}"
